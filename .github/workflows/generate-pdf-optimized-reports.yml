name: Generate PDF-Optimized Reports

on:
  workflow_dispatch:
    inputs:
      json_file:
        description: 'Path to JSON file (leave empty for most recent)'
        required: false
        default: ''
  workflow_run:
    workflows: ["Test Comprehensive Pipeline"]
    types:
      - completed

jobs:
  generate-pdf-optimized-report:
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch' }}
    timeout-minutes: 20
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
    
    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'
    
    - name: Install dependencies
      run: |
        # PDF conversion dependencies
        sudo apt-get update
        sudo apt-get install -y \
          libpango-1.0-0 \
          libpangoft2-1.0-0 \
          libharfbuzz0b \
          libfribidi0 \
          libgdk-pixbuf2.0-0 \
          shared-mime-info
        
        # Python packages
        pip install weasyprint
        pip install pandas numpy
        pip install -r requirements.txt || echo "requirements.txt not found"
    
    - name: Download pipeline artifacts (if triggered by workflow)
      if: github.event_name == 'workflow_run'
      uses: actions/download-artifact@v4
      continue-on-error: true
      with:
        pattern: comprehensive-analysis-*
        path: pipeline_output/
        run-id: ${{ github.event.workflow_run.id }}
        merge-multiple: true
    
    - name: Find or Create JSON file
      run: |
        echo "================================"
        echo "FINDING OR GENERATING JSON DATA"
        echo "================================"
        
        FORCE="${FORCE_GENERATE:-false}"
        
        # Check if user provided a specific file
        if [ -n "${{ github.event.inputs.json_file }}" ]; then
          JSON_FILE="${{ github.event.inputs.json_file }}"
          echo "üìÅ User specified: $JSON_FILE"
          
          if [ ! -f "$JSON_FILE" ]; then
            echo "‚ùå ERROR: Specified file not found: $JSON_FILE"
            exit 1
          fi
        else
          # Look for existing JSON files
          echo "üîç Searching for comprehensive_*.json files..."
          JSON_FILE=$(find . -name "comprehensive_*.json" -type f -printf '%T@ %p\n' 2>/dev/null | sort -rn | head -1 | cut -d' ' -f2-)
          
          if [ -n "$JSON_FILE" ] && [ "$FORCE" != "true" ]; then
            echo "‚úÖ Found existing JSON: $JSON_FILE"
          else
            if [ "$FORCE" == "true" ]; then
              echo "üîÑ Force generation requested"
            else
              echo "‚ö†Ô∏è  No JSON file found"
            fi
            
            echo "üöÄ Running comprehensive pipeline to generate data..."
            echo ""
            
            # Run the comprehensive pipeline
            python comprehensive_pipeline.py 2>&1 | tee pipeline_run.log
            
            PIPELINE_EXIT=$?
            
            if [ $PIPELINE_EXIT -ne 0 ]; then
              echo ""
              echo "‚ùå Pipeline failed with exit code: $PIPELINE_EXIT"
              echo "Last 50 lines of output:"
              tail -50 pipeline_run.log
              exit 1
            fi
            
            # Find the newly generated JSON
            echo ""
            echo "üîç Looking for generated JSON file..."
            JSON_FILE=$(find . -name "comprehensive_*.json" -type f -printf '%T@ %p\n' 2>/dev/null | sort -rn | head -1 | cut -d' ' -f2-)
            
            if [ -z "$JSON_FILE" ]; then
              echo "‚ùå ERROR: Pipeline completed but no JSON file was generated"
              echo ""
              echo "Generated files:"
              find . -name "*.json" -type f -mmin -10
              exit 1
            fi
            
            echo "‚úÖ Generated new data: $JSON_FILE"
          fi
        fi
        
        # Verify the file exists and is valid JSON
        if [ ! -f "$JSON_FILE" ]; then
          echo "‚ùå ERROR: JSON file not found: $JSON_FILE"
          exit 1
        fi
        
        # Quick JSON validation
        if ! python -c "import json; json.load(open('$JSON_FILE'))" 2>/dev/null; then
          echo "‚ùå ERROR: Invalid JSON file: $JSON_FILE"
          exit 1
        fi
        
        FILE_SIZE=$(du -h "$JSON_FILE" | cut -f1)
        echo ""
        echo "================================"
        echo "‚úÖ JSON FILE READY"
        echo "================================"
        echo "File: $JSON_FILE"
        echo "Size: $FILE_SIZE"
        echo "================================"
        
        echo "json_file=$JSON_FILE" >> $GITHUB_OUTPUT
    - name: Generate AI-powered HTML report with Local LLM
      run: |
        echo "================================"
        echo "GENERATING AI-POWERED REPORT"
        echo "Using: BIST-Financial-Qwen-7B"
        echo "Mode: Local LLM (No API needed)"
        echo "================================"
        python local_llm_report_generator.py "${{ steps.find-json.outputs.json_file }}"
  
    - name: Find html
      run: |
        # Look for PDF-optimized HTML first
        HTML_FILE=$(find . -name "*_pdf_optimized.html" -type f | head -1)
        
        # Fall back to any AI report HTML
        if [ -z "$HTML_FILE" ]; then
          HTML_FILE=$(find . -name "*_ai_report.html" -type f | head -1)
        fi
        
        if [ -z "$HTML_FILE" ]; then
          echo "‚ùå No HTML file generated"
          exit 1
        fi
        
        echo "html_file=$HTML_FILE" >> $GITHUB_OUTPUT
        echo "‚úì Found HTML: $HTML_FILE"
    
    - name: Convert HTML to PDF with WeasyPrint
      run: |
        echo "================================"
        echo "CONVERTING TO PDF"
        echo "================================"
        
        HTML_FILE="${{ steps.find-html.outputs.html_file }}"
        OUTPUT_PDF="${HTML_FILE%.html}.pdf"
        
        if [ -f html_to_pdf.py ]; then
          python html_to_pdf.py "$HTML_FILE" "$OUTPUT_PDF" --method weasyprint
        else
          echo "Using WeasyPrint directly..."
          python -c "
        from weasyprint import HTML, CSS
        
        html_file = '$HTML_FILE'
        pdf_file = '$OUTPUT_PDF'
        
        # Additional CSS for PDF
        pdf_css = CSS(string='''
            @page {
                size: A4;
                margin: 2cm 1.5cm;
            }
            
            .section {
                page-break-inside: avoid;
            }
            
            table {
                page-break-inside: avoid;
            }
        ''')
        
        HTML(filename=html_file).write_pdf(
            pdf_file,
            stylesheets=[pdf_css],
            optimize_images=True,
            jpeg_quality=85
        )
        
        print(f'‚úì PDF generated: {pdf_file}')
          "
        fi
        
        echo "pdf_file=$OUTPUT_PDF" >> $GITHUB_OUTPUT
    
    - name: Verify PDF quality
      run: |
        PDF_FILE=$(find . -name "*_pdf_optimized.pdf" -o -name "*_ai_report.pdf" | head -1)
        
        if [ ! -f "$PDF_FILE" ]; then
          echo "‚ùå PDF file not found"
          exit 1
        fi
        
        SIZE=$(stat -c%s "$PDF_FILE")
        SIZE_KB=$(echo "scale=2; $SIZE/1024" | bc)
        SIZE_MB=$(echo "scale=2; $SIZE/1024/1024" | bc)
        
        echo "================================"
        echo "PDF QUALITY CHECK"
        echo "================================"
        echo "File: $PDF_FILE"
        echo "Size: $SIZE bytes"
        echo "      $SIZE_KB KB"
        echo "      $SIZE_MB MB"
        echo ""
        
        # Basic quality checks
        if [ $SIZE -lt 5000 ]; then
          echo "‚ö†Ô∏è  WARNING: PDF file is very small ($SIZE bytes)"
          echo "This may indicate rendering issues"
        elif [ $SIZE -lt 50000 ]; then
          echo "‚úì PDF size reasonable for simple content"
        else
          echo "‚úì PDF size looks good for comprehensive report"
        fi
        
        # Check if file is valid PDF
        if file "$PDF_FILE" | grep -q "PDF"; then
          echo "‚úì File is valid PDF format"
        else
          echo "‚ùå File may not be valid PDF"
          exit 1
        fi
    
    - name: Upload HTML and PDF reports
      uses: actions/upload-artifact@v4
      with:
        name: pdf-optimized-reports-${{ github.run_number }}
        path: |
          **/*_pdf_optimized.html
          **/*_pdf_optimized.pdf
          **/*_ai_report.html
          **/*_ai_report.pdf
        retention-days: 90
    
    - name: Upload input data
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: input-data-${{ github.run_number }}
        path: |
          ${{ steps.find-json.outputs.json_file }}
        retention-days: 30
    
    - name: Display summary
      if: success()
      run: |
        echo "================================"
        echo "PDF REPORT GENERATION COMPLETE"
        echo "================================"
        echo ""
        echo "üìä Input JSON: ${{ steps.find-json.outputs.json_file }}"
        echo "üåê HTML Report: ${{ steps.find-html.outputs.html_file }}"
        echo ""
        echo "üìÑ PDF Reports:"
        find . -name "*_pdf_optimized.pdf" -o -name "*_ai_report.pdf" | while read pdf; do
          SIZE=$(du -h "$pdf" | cut -f1)
          echo "  - $pdf ($SIZE)"
        done
        echo ""
        echo "üì• Download from: Actions > This Run > Artifacts"
        echo ""
        echo "‚úÖ Generation complete!"
        echo "================================"
    
    - name: Display failure info
      if: failure()
      run: |
        echo "================================"
        echo "‚ùå WORKFLOW FAILED"
        echo "================================"
        echo ""
        echo "Check the logs above for details."
        echo ""
        echo "Common issues:"
        echo "1. Missing JSON data file"
        echo "2. WeasyPrint rendering errors"
        echo "3. Invalid JSON structure"
        echo "4. CSS/HTML formatting issues"
        echo ""
        echo "Generated files:"
        find . -name "*.json" -o -name "*.html" -o -name "*.pdf" | head -20
